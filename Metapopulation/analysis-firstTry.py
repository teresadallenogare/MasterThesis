"""

--------------------------------------------------------------------

Author : Teresa Dalle Nogare
Version : 15 October 2023

--------------------------------------------------------------------

First try of analysis of data generated of the SIR epidemic model with a metapopulation approach.
The trial is to use a line of reasoning similar to the one applied in the paper: "Topological data analysis model for
the spread of the coronavirus ". In this case, data are generated by our model of the contagion spreading on a network.
First point is to generate data of a contagion process.
The second point is to analyse them using TDA models. To do so, data that are taken into account for this first attempt
of analysis are:
1. x position of node
2. y position of node
3. Cumulative number of I per node
4. Time step
I thus have a 4-dimensional vector for each node and for each time step.

"""
import numpy as np
import matplotlib.pyplot as plt
import os
import sklearn
import kmapper as km
import networkx as nx
# Consider the case of an epidemic outbreak on a 3x3 network
N_row = 3
N_col = 3
N = N_row * N_col
choice_bool = 0
datadir = os.getcwd()
c1 = 0  # for now
beta = 0.4
mu = 0.2

folder_topology = datadir + f'/Data-simpleLattice/{N_row}x{N_col}/choice_bool-{choice_bool}/c1-{int(np.floor(c1))}/Topology/'
folder_simulation = datadir + f'/Data-simpleLattice/{N_row}x{N_col}/choice_bool-{choice_bool}/c1-{int(np.floor(c1))}/Simulations/beta-{beta}mu-{mu}/'

avg_popPerNode = np.load(folder_topology + '/avg_popPerNode.npy')
populationTot = N * avg_popPerNode # from this then I use multinomial
if choice_bool == 1:
    Nfix = np.load(folder_topology + '/Nfix.npy')
    percentage_FixNodes = np.load(folder_topology + '/percentage_FixNodes.npy')
else:
    Nfix = 0
    percentage_FixNodes = 0

T = np.load(folder_simulation + 'T.npy')
node_population_time = np.load(folder_simulation + 'node_population_time.npy')
node_NS_time = np.load(folder_simulation + 'node_NS_time.npy')
node_NI_time = np.load(folder_simulation + 'node_NI_time.npy')
density_node_NI_time = node_NI_time / populationTot # normalisation (density of infected as a global property?)
node_NR_time = np.load(folder_simulation + 'node_NR_time.npy')

pos_nodes = np.load(folder_topology + 'pos_nodes.npy')

# New infected per time step in the whole network
new_I = np.array([np.sum(node_NI_time[i, :]) for i in range(T)])
plt.plot(new_I)
plt.show()
# 1. Extract coordinates of nodes
x_nodes = [pos_nodes[i][0] for i in range(N)]
y_nodes = [pos_nodes[i][1] for i in range(N)]
print(x_nodes)
print(y_nodes)

# 2. Calculate the cumulative number of infected individuals per node over the whole period of time
cumulat_I_perNode = np.zeros(shape =(T+1, N))

for i in range(N):
   cumulat_I_perNode[:, i] = np.cumsum(density_node_NI_time[:, i])


# 3. Create 4-dimensional vectors (rows of a matrix)
# dict_4d_vectors is a dictionary that at every <key> = label node assign a matrix that is of dimension [T x 4] :
# (x_node, y_node, cumulative # I, time)
dict_4d_vectors = {}
# Cycle over th nodes
for i in range(N):
    # I have T rows because I have values of infections for every time step
    for t in range(T):
        if t == 0:
            array_node_0 = np.array([x_nodes[i], y_nodes[i], cumulat_I_perNode[t, i], t])
        elif t == 1:
            array_node_1 = np.array([x_nodes[i], y_nodes[i], cumulat_I_perNode[t, i], t])
            mtrx_node = np.vstack((array_node_0, array_node_1))
        else:
            # I have 4 columns because I have 4 elements in the vectors
            array_node_t = np.array([x_nodes[i], y_nodes[i], cumulat_I_perNode[t, i], t])
            mtrx_node = np.vstack((mtrx_node, array_node_t))
    dict_4d_vectors[i] = mtrx_node

# Kmapper
# Initialization (?)
mapper = km.KeplerMapper(verbose=0)

# Fit and transform data
mtrx_nodes_vals = list(dict_4d_vectors.values())
# all vectors (row) on a matrix
for i in range(N):
    if i == 0:
        mtrx_node_0 = mtrx_nodes_vals[0]
    elif i == 1:
        mtrx_node_1 = mtrx_nodes_vals[1]
        mtrx_tot = np.vstack((mtrx_node_0, mtrx_node_1))
    else:
        mtrx_node_i = mtrx_nodes_vals[i]
        mtrx_tot = np.vstack((mtrx_tot, mtrx_node_i))
# project to themselves (but different values!!)
mtrx_tot_proj = mapper.project(mtrx_tot, projection=[0,1,2,3])
graph = mapper.map(mtrx_tot_proj, clusterer = sklearn.cluster.DBSCAN(metric='euclidean'), cover=km.Cover(n_cubes=3, perc_overlap=0.1) )
# convert graph of mapper into a nx graph
nx_graph = km.adapter.to_nx(graph)
nx.draw(nx_graph)
# plot on html
html = mapper.visualize(graph, path_html="kepler-mapper-output2.html")


fig, ax = plt.subplots(3, 1)
pos0 = ax[0].imshow(node_NS_time.T, cmap = 'coolwarm')
ax[0].set_xlabel('Time')
ax[0].set_ylabel('node idx')
ax[0].set_title('Number susceptible - infected - recovered over time')
pos1 = ax[1].imshow(node_NI_time.T, cmap = 'coolwarm')
ax[1].set_xlabel('Time')
ax[1].set_ylabel('node idx')
pos2 = ax[2].imshow(node_NR_time.T, cmap = 'coolwarm')
ax[2].set_xlabel('Time')
ax[2].set_ylabel('node idx')
fig.colorbar(pos0, ax=ax[0])
fig.colorbar(pos1, ax=ax[1])
fig.colorbar(pos2, ax=ax[2])

plt.show()